import { App } from 'vue';
import { Plugin as Plugin_2 } from 'vue';
import { Ref } from 'vue';

/**
 * Creates a Pinia instance to be used by the application
 */
export declare function createPinia(): Pinia;

/**
 * {@inheritDoc defineStore}
 * @deprecated Use {@link defineStore}
 */
export declare const createStore: typeof defineStore;

declare type DeepPartial<T> = {
    [K in keyof T]?: DeepPartial<T[K]>;
};

/**
 * Creates a `useStore` function that retrieves the store instance
 * @param options - options to define the store
 */
export declare function defineStore<Id extends string, S extends StateTree, G, A>(options: DefineStoreOptions<Id, S, G, A>): StoreDefinition<Id, S, G, A>;

/**
 * Options parameter of `defineStore()`. Can be extended to augment stores with
 * the plugin API.
 */
export declare interface DefineStoreOptions<Id extends string, S extends StateTree, G, A> {
    id: Id;
    state?: () => S;
    getters?: G & ThisType<S & StoreWithGetters<G> & PiniaCustomProperties>;
    actions?: A & ThisType<A & S & StoreWithState<Id, S> & StoreWithGetters<G> & PiniaCustomProperties>;
}

/**
 * Generic version of Store.
 */
declare type GenericStore = Store<string, StateTree, Record<string, Method>, Record<string, Method>>;

/**
 * Generic version of `StoreDefinition`.
 */
declare type GenericStoreDefinition = StoreDefinition<string, StateTree, Record<string, Method>, Record<string, Method>>;

/**
 * Allows directly using actions from your store without using the composition
 * API (`setup()`) by generating an object to be spread in the `methods` field
 * of a component. The values of the object are the actions while the keys are
 * the names of the resulting methods.
 *
 * @example
 * ```js
 * export default {
 *   methods: {
 *     // other methods properties
 *     // useCounterStore has two actions named `increment` and `setCount`
 *     ...mapActions(useCounterStore, { moar: 'increment', setIt: 'setCount' })
 *   },
 *
 *   created() {
 *     this.moar()
 *     this.setIt(2)
 *   }
 * }
 * ```
 *
 * @param useStore - store to map from
 * @param keyMapper - object to define new names for the actions
 */
export declare function mapActions<Id extends string, S extends StateTree, G, A, KeyMapper extends Record<string, keyof A>>(useStore: StoreDefinition<Id, S, G, A>, keyMapper: KeyMapper): MapActionsObjectReturn<A, KeyMapper>;

/**
 * Allows directly using actions from your store without using the composition
 * API (`setup()`) by generating an object to be spread in the `methods` field
 * of a component.
 *
 * @example
 * ```js
 * export default {
 *   methods: {
 *     // other methods properties
 *     ...mapActions(useCounterStore, ['increment', 'setCount'])
 *   },
 *
 *   created() {
 *     this.increment()
 *     this.setCount(2) // pass arguments as usual
 *   }
 * }
 * ```
 *
 * @param useStore - store to map from
 * @param keys - array of action names to map
 */
export declare function mapActions<Id extends string, S extends StateTree, G, A>(useStore: StoreDefinition<Id, S, G, A>, keys: Array<keyof A>): MapActionsReturn<A>;

declare type MapActionsObjectReturn<A, T extends Record<string, keyof A>> = {
    [key in keyof T]: Store<string, StateTree, {}, A>[T[key]];
};

declare type MapActionsReturn<A> = {
    [key in keyof A]: Store<string, StateTree, {}, A>[key];
};

/**
 * Alias for `mapState()`. You should use `mapState()` instead.
 * @deprecated use `mapState()` instead.
 */
export declare const mapGetters: typeof mapState;

/**
 * Allows using state and getters from one store without using the composition
 * API (`setup()`) by generating an object to be spread in the `computed` field
 * of a component. The values of the object are the state properties/getters
 * while the keys are the names of the resulting computed properties.
 * Optionally, you can also pass a custom function that will receive the store
 * as its first argument. Note that while it has access to the component
 * instance via `this`, it won't be typed.
 *
 * @example
 * ```js
 * export default {
 *   computed: {
 *     // other computed properties
 *     // useCounterStore has a state property named `count` and a getter `double`
 *     ...mapState(useCounterStore, {
 *       n: 'count',
 *       triple: store => store.n * 3,
 *       // note we can't use an arrow function if we want to use `this`
 *       custom(store) {
 *         return this.someComponentValue + store.n
 *       },
 *       doubleN: 'double'
 *     })
 *   },
 *
 *   created() {
 *     this.n // 2
 *     this.doubleN // 4
 *   }
 * }
 * ```
 *
 * @param useStore - store to map from
 * @param keyMapper - object of state properties or getters
 */
export declare function mapState<Id extends string, S extends StateTree, G, A, KeyMapper extends Record<string, keyof S | keyof G | ((store: Store<Id, S, G, A>) => any)>>(useStore: StoreDefinition<Id, S, G, A>, keyMapper: KeyMapper): MapStateObjectReturn<Id, S, G, A, KeyMapper>;

/**
 * Allows using state and getters from one store without using the composition
 * API (`setup()`) by generating an object to be spread in the `computed` field
 * of a component.
 *
 * @example
 * ```js
 * export default {
 *   computed: {
 *     // other computed properties
 *     ...mapState(useCounterStore, ['count', 'double'])
 *   },
 *
 *   created() {
 *     this.count // 2
 *     this.double // 4
 *   }
 * }
 * ```
 *
 * @param useStore - store to map from
 * @param keys - array of state properties or getters
 */
export declare function mapState<Id extends string, S extends StateTree, G, A>(useStore: StoreDefinition<Id, S, G, A>, keys: Array<keyof S | keyof G>): MapStateReturn<S, G>;

declare type MapStateObjectReturn<Id extends string, S extends StateTree, G, A, T extends Record<string, keyof S | keyof G | ((store: Store<Id, S, G, A>) => any)>> = {
    [key in keyof T]: () => T[key] extends (store: GenericStore) => infer R ? R : T[key] extends keyof S | keyof G ? Store<Id, S, G, A>[T[key]] : never;
};

declare type MapStateReturn<S extends StateTree, G> = {
    [key in keyof S | keyof G]: () => Store<string, S, G, {}>[key];
};

/**
 * Allows using stores without the composition API (`setup()`) by generating an
 * object to be spread in the `computed` field of a component. It accepts a list
 * of store definitions.
 *
 * @example
 * ```js
 * export default {
 *   computed: {
 *     // other computed properties
 *     ...mapStores(useUserStore, useCartStore)
 *   },
 *
 *   created() {
 *     this.userStore // store with id "user"
 *     this.cartStore // store with id "cart"
 *   }
 * }
 * ```
 *
 * @param stores - list of stores to map to an object
 */
export declare function mapStores<Stores extends GenericStoreDefinition[]>(...stores: [...Stores]): Spread<Stores>;

/**
 * Interface to allow customizing map helpers. Extend this interface with the
 * following properties:
 *
 * - `suffix`: string. Affects the suffix of `mapStores()`, defaults to `Store`.
 */
export declare interface MapStoresCustomization {
}

/**
 * Same as `mapState()` but creates computed setters as well so the state can be
 * modified. Differently from `mapState()`, only `state` properties can be
 * added.
 *
 * @param useStore - store to map from
 * @param keyMapper - object of state properties
 */
export declare function mapWritableState<Id extends string, S extends StateTree, G, A, KeyMapper extends Record<string, keyof S>>(useStore: StoreDefinition<Id, S, G, A>, keyMapper: KeyMapper): MapWritableStateObjectReturn<S, KeyMapper>;

/**
 * Allows using state and getters from one store without using the composition
 * API (`setup()`) by generating an object to be spread in the `computed` field
 * of a component.
 *
 * @param useStore - store to map from
 * @param keys - array of state properties
 */
export declare function mapWritableState<Id extends string, S extends StateTree, G, A>(useStore: StoreDefinition<Id, S, G, A>, keys: Array<keyof S>): MapWritableStateReturn<S>;

declare type MapWritableStateObjectReturn<S extends StateTree, T extends Record<string, keyof S>> = {
    [key in keyof T]: {
        get: () => Store<string, S, {}, {}>[T[key]];
        set: (value: Store<string, S, {}, {}>[T[key]]) => any;
    };
};

declare type MapWritableStateReturn<S extends StateTree> = {
    [key in keyof S]: {
        get: () => Store<string, S, {}, {}>[key];
        set: (value: Store<string, S, {}, {}>[key]) => any;
    };
};

declare type Method = (...args: any[]) => any;

/**
 * Every application must own its own pinia to be able to create stores
 */
export declare interface Pinia {
    install: Exclude<Plugin_2['install'], undefined>;
    /**
     * root state
     */
    state: Ref<Record<string, StateTree>>;
    /**
     * Adds a store plugin to extend every store
     *
     * @param plugin - store plugin to add
     */
    use(plugin: PiniaStorePlugin): void;
    /**
     * Installed store plugins
     *
     * @internal
     */
    _p: Array<() => Partial<PiniaCustomProperties>>;
}

/**
 * Properties that are added to every store by `pinia.use()`
 */
export declare interface PiniaCustomProperties<Id extends string = string, S extends StateTree = StateTree, G = Record<string, Method>, A = Record<string, Method>> {
}

/**
 * Plugin to extend every store
 */
export declare interface PiniaStorePlugin {
    (app: App): Partial<PiniaCustomProperties>;
}

/**
 * Sets or unsets the active pinia. Used in SSR and internally when calling
 * actions and getters
 *
 * @param pinia - Pinia instance
 */
export declare const setActivePinia: (pinia: Pinia | undefined) => Pinia | undefined;

/**
 * Changes the suffix added by `mapStores()`. Can be set to an empty string.
 * Defaults to `"Store"`. Make sure to extend the MapStoresCustomization
 * interface if you need are using TypeScript.
 *
 * @param suffix - new suffix
 */
export declare function setMapStoreSuffix(suffix: 'suffix' extends keyof MapStoresCustomization ? MapStoresCustomization['suffix'] : string): void;

declare type Spread<A extends readonly any[]> = A extends [infer L, ...infer R] ? StoreObject<L> & Spread<R> : unknown;

/**
 * Generic state of a Store
 */
export declare type StateTree = Record<string | number | symbol, any>;

/**
 * Store type to build a store
 */
export declare type Store<Id extends string, S extends StateTree, G, A> = StoreWithState<Id, S> & S & StoreWithGetters<G> & StoreWithActions<A> & PiniaCustomProperties<Id, S, G, A>;

/**
 * Return type of `defineStore()`. Function that allows instantiating a store.
 */
declare interface StoreDefinition<Id extends string, S extends StateTree, G, A> {
    (pinia?: Pinia | null | undefined): Store<Id, S, G, A>;
    $id: Id;
}

declare type StoreObject<S> = S extends StoreDefinition<infer Ids, infer State, infer Getters, infer Actions> ? {
    [Id in `${Ids}${'suffix' extends keyof MapStoresCustomization ? MapStoresCustomization['suffix'] : 'Store'}`]: () => Store<Id extends `${infer RealId}${'suffix' extends keyof MapStoresCustomization ? MapStoresCustomization['suffix'] : 'Store'}` ? RealId : string, State, Getters, Actions>;
} : {};

/**
 * Store augmented for actions
 * @internal
 */
export declare type StoreWithActions<A> = {
    [k in keyof A]: A[k] extends (...args: infer P) => infer R ? (...args: P) => R : never;
};

/**
 * Store augmented with getters
 * @internal
 */
export declare type StoreWithGetters<G> = {
    [k in keyof G]: G[k] extends (this: infer This, store?: any) => infer R ? R : never;
};

/**
 * Base store with state and functions
 * @internal
 */
export declare interface StoreWithState<Id extends string, S extends StateTree> {
    /**
     * Unique identifier of the store
     */
    $id: Id;
    /**
     * State of the Store. Setting it will replace the whole state.
     */
    $state: S;
    /**
     * Private property defining the pinia the store is attached to.
     *
     * @internal
     */
    _p: Pinia;
    /**
     * Applies a state patch to current state. Allows passing nested values
     *
     * @param partialState - patch to apply to the state
     */
    $patch(partialState: DeepPartial<S>): void;
    /**
     * Group multiple changes into one function. Useful when mutating objects like
     * Sets or arrays and applying an object patch isn't practical, e.g. appending
     * to an array.
     *
     * @param stateMutator - function that mutates `state`, cannot be async
     */
    $patch<F extends (state: S) => void>(stateMutator: ReturnType<F> extends Promise<any> ? never : F): void;
    /**
     * Resets the store to its initial state by building a new state object.
     */
    $reset(): void;
    /**
     * Setups a callback to be called whenever the state changes.
     *
     * @param callback - callback passed to the watcher
     * @returns function that removes the watcher
     */
    $subscribe(callback: SubscriptionCallback<S>): () => void;
}

declare type SubscriptionCallback<S> = (mutation: {
    storeName: string;
    type: string;
    payload: DeepPartial<S>;
}, state: S) => void;

export { }
