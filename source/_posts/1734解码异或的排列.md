---
title: 1734解码异或的排列
date: 2021-05-12 12:29:27
tags:
	- 算法
	- Python
	- 异或
categories: 算法
cover: /images/banners/VCG41N1126025444.jpg
---

### 给你一个整数数组 perm ，它是前 n 个正整数的排列，且 n 是个 奇数 。它被加密成另一个长度为 n - 1 的整数数组 encoded ，满足 encoded[i] = perm[i] XOR perm[i + 1] 。比方说，如果 perm = [1,3,2] ，那么 encoded = [2,1] 。给你 encoded 数组，请你返回原始数组 perm 。题目保证答案存在且唯一。

**示例 1：**
输入：encoded = [3,1]
输出：[1,2,3]
解释：如果 perm = [1,2,3] ，那么 encoded = [1 XOR 2,2 XOR 3] = [3,1]

**示例 2：**
输入：encoded = [6,5,4,6]
输出：[2,4,1,5,3]

**此题是leetcode 1720的升级版**

## 一、解法一：通过数据解题思路（异或运算）

### 1.1 思路

我在LeetCode上面看题解的时候，看得好吃力，完全没看懂，然后跟着思路用纸写一遍，突然就懂了。话不多说，开始：

**我们知道异或运算有如下性质（不懂的话，可以查一下，不多做解释了）：**

1. 相同数值异或，结果为 0
2. 任意数值与 0 进行异或，结果为数值本身
3. 异或本身满足交换律

**⊕：代表异或**

**本题需要我们求perm（需求一步一步往下看，不然会不懂）**

1. 根据题目意思 ，假设 perm = [a, b, c, d, e]，那么 encoded = [ab, bc, cd, de]

2. 先求出perm[0]  ,    perm[0] =   (perm[0] ⊕ perm[1] ... ⊕ perm[n] )  ⊕    (perm[1] ...⊕ perm[n] )   ,根据相同值异或为0性质，异或结果就是perm[0]，看懂了再往下走

   * 此时我们只需要求出**(perm[0] ⊕ perm[1] ... ⊕ perm[n] )** 和**(perm[1] ...⊕ perm[n] )**的值，他俩异或的结果就可以求出**perm[0]**

3. 求第2步的两个值：

   * **(perm[0] ⊕ perm[1] ... ⊕ perm[n] )**，题目已经告诉我们的，他是前 n 个正整数的排列，假如n=5 ,他结果就是**1⊕ 2⊕ 3⊕ 4⊕ 5**,
   * **(perm[1] ...⊕ perm[n] )**,这个值看如下举例：

   假设 perm = [a, b, c, d, e]，那么 encoded = [ab, bc, cd, de]

   **perm[1] ⊕ perm[2] ...⊕ perm[n]  =  encoded[1] ⊕ encoded[3]   (步长为2)**

   * encoded都是题目给出来的值 ，是不是很好求
   * 这样你就可以结合第二步，求出**perm[0]**的值

4. 题目给出**encoded[i] = perm[i] ⊕ perm[i + 1]**    可以理解为：**encoded[i] = perm[i] ⊕ perm[i - 1]**    一样的意思， 只是我把下标 **i**理解为当前这个数和当前数的前一个

	* ​	encoded[0] = perm[0] ⊕ perm[1]  两边同时异或 perm[1],  根据相同为0，得出如下
	* ​    perm[1] = encoded[0] ⊕ perm[0]
	* ​    perm[i] = encoded[i] ⊕ perm[i - 1]



**最后再去看代码，就很清晰了，总结的不好的，欢迎留言指正；**

```python
class Solution:
    def decode(self, encoded: List[int]) -> List[int]:
        n = len(encoded) + 1
        
        perm_total = reduce(xor, range(1, len(encoded) + 2))
        
        child_total = 0
        for i in range(1, len(encoded), 2):
            child_total ^= encoded[i]
           
        perm = [perm_total ^ child_total]
        
        for j in range(1, len(encoded) + 1):
            perm.append(encoded[j - 1] ^ perm[j - 1])
        return perm
```





