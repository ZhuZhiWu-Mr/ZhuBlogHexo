---
title: 7整数反转
date: 2021-05-04 00:27:50
tags:
	- 算法
	- Python
categories: 
	- 算法
cover: /images/banners/VCG211263245974.jpg
feature: true
---

给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。假设环境不允许存储 64 位整数（有符号或无符号）

## 1、解法1，未优化写法   40ms

### 思路：
   （1）这个题挺简单，就是通过%运算，每次都取到数的最后一位
   （2）考虑到负数的问题，所以while那里使用了 x!=0，因为按这种方式计算，最后都会为0
   （3）注意题目规定的整数范围，这里代码做了提前一位的判断。看下图解

   ![](/post/7整数反转/image-20210504005805249.png)

   第二排数字中，橘子的是5，它是大于上面同位置的4，这就意味着5后跟任何数字，都会比最大32为整数都大。
   所以，我们到【最大数的1/10】时，就要开始判断了
   如果某个数字**大于** 214748364那后面就不用再判断了，肯定溢出了。
   如果某个数字**等于** 214748364呢，这对应到上图中第三、第四、第五排的数字，需要要跟最大数的**末尾数字**比较，如果这个数字比**7**还大，说明溢出了。



**负数也是一样：**

![](/post/7整数反转/image-20210504010425266.png)

上图中绿色部分是最小的32位整数，同样是在【最小数的 1/10】时开始判断
如果某个数字**小于** -214748364说明溢出了
如果某个数字**等于** -214748364，还需要跟最小数的**末尾比较**，即看它是否**小于8**

### 遇到问题：
	因为Python 的%运算，是使用的floor的方式，在计算负数的时候，会出现和Java不同，所以，都转成正数来取模运算
```python
class Solution:
    def reverse(self, x: int) -> int:
        reverse_num = 0
        # 2147483647
        # -2147483648
        while(x != 0):
            if x < 0:
                tmp_num = -x % 10
                tmp_num = -tmp_num
            else:
                tmp_num = x % 10
            # 判断是否溢出
            if (reverse_num > 214748364) or (reverse_num == 214748364 and tmp_num > 7):
                return 0
            if (reverse_num < -214748364) or (reverse_num == 214748364 and tmp_num > 7):
                return 0
            reverse_num = reverse_num * 10 + tmp_num
            x = int(x/10)
        return reverse_num
```

## 2、 将解法1所写的代码进行优化   32ms
```python
class Solution:
    def reverse(self, x: int) -> int:
        # 2147483647
        # -2147483648
        y, res = abs(x), 0
        while(y != 0):
            tmp_num = y % 10
            # 判断是否溢出
            if res < -214748364:
                return 0
            if (res > 214748364) or (res == 214748364 and tmp_num > 7):
                return 0
            res = res * 10 + tmp_num
            y = int(y/10)
        return res if x > 0 else -res
```

## 3、使用字符串反转的方法  36ms
```python
class Solution:
    def reverse(self, x: int) -> int:
        y = str(x)
        ins = 1
        res = ""
        if y[0] == "-":
            ins = -1
            res = y[1:][::-1]
        else:
            res = y[::-1]
        nums = int(res)
        return 0 if nums <-2**31 or nums > 2**31-1 else (ins * nums)
```

### 题目总结：
	在用字符串反转的方法时，我发现Ptyhon这样将字符串进行转换，整型不会内存溢出，很好奇的我，去网上查阅了资料，发现Python3之后，都是统一使用了长整型

现在是2021年5月4号零晨1:45分，这是我刷leetcode的第三道题，每次将自己写的一串很长的代码，优化成很简单，看着自己的代码运行时间越写越短，内心有一点无比自豪的感觉，很喜欢这种超越自己的，继续加油吧。哈哈哈哈哈哈